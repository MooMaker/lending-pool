// SPDX-License-Identifier: AGPLv3
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Wrapper.sol";

import "../configuration/AddressesProvider.sol";
import "../LendingPool.sol";
import "../LendingPoolCore.sol";
import "../libraries/WadRayMath.sol";


contract AToken is ERC20Wrapper {
    using SafeMath for uint256;
    using WadRayMath for uint256;

    AddressesProvider public addressesProvider;

    address public underlyingAssetAddress;

    mapping (address => uint256) private userIndexes;

    uint8 private _decimals;

    LendingPoolCore private core;
    LendingPool private pool;

    /**
    * @dev emitted after the mint action
    * @param _from the address performing the mint
    * @param _value the amount to be minted
    * @param _fromBalanceIncrease the cumulated balance since the last update of the user
    * @param _fromIndex the last index of the user
    **/
    event MintOnDeposit(
        address indexed _from,
        uint256 _value,
        uint256 _fromBalanceIncrease,
        uint256 _fromIndex
    );

    modifier onlyLendingPool {
        require(
            msg.sender == address(pool),
            "The caller of this function must be a lending pool"
        );
        _;
    }

    constructor(
        AddressesProvider _addressesProvider,
        IERC20 _underlyingAsset,
        uint8 _underlyingAssetDecimals,
        string memory _name,
        string memory _symbol
    ) ERC20(_name, _symbol) ERC20Wrapper(_underlyingAsset) {
        addressesProvider = _addressesProvider;
        underlyingAssetAddress = address(_underlyingAsset);
        _decimals = _underlyingAssetDecimals;
        core = LendingPoolCore(addressesProvider.getLendingPoolCore());
        pool = LendingPool(addressesProvider.getLendingPool());
    }

    function decimals() override public view returns(uint8) {
        return _decimals;
    }

    /**
    * @dev calculates the balance of the user, which is the
    * principal balance + interest generated by the principal balance + interest generated by the redirected balance (TODO: do we need to handle redirected balance?)
    * @param _user the user for which the balance is being calculated
    * @return the total balance of the user
    **/
    function balanceOf(address _user) override public view returns(uint256) {

        //current principal balance of the user
        uint256 currentPrincipalBalance = super.balanceOf(_user);

        // TODO(redirects): do we need it?
        // balance redirected by other users to _user for interest rate accrual
        // uint256 redirectedBalance = redirectedBalances[_user];

        if(currentPrincipalBalance == 0 /* && redirectedBalance == 0 */){
            return 0;
        }

        // TODO(redirects): do we need it?
        // if the _user is not redirecting the interest to anybody, accrues
        // the interest for himself
//        if(interestRedirectionAddresses[_user] == address(0)) {
            //accruing for himself means that both the principal balance and
            //the redirected balance partecipate in the interest

        // Calculate the accrued interest since the last accumulation
        return calculateCumulatedBalanceInternal(
            _user,
            currentPrincipalBalance /** .add(redirectedBalance) */
        ); /** .sub(redirectedBalance);*/
//        }
//        else {
//            //if the user redirected the interest, then only the redirected
//            //balance generates interest. In that case, the interest generated
//            //by the redirected balance is added to the current principal balance.
//            return currentPrincipalBalance.add(
//                calculateCumulatedBalanceInternal(
//                    _user,
//                    redirectedBalance
//                )
//                .sub(redirectedBalance)
//            );
//        }
    }

    /**
     * @dev mints token in the event of users depositing the underlying asset into the lending pool
     * only lending pools can call this function
     * @param _account the address receiving the minted tokens
     * @param _amount the amount of tokens to mint
     */
    function mintOnDeposit(address _account, uint256 _amount) external onlyLendingPool {
        // Cumulate balance checks accrued interest since the last action
        // and mints a corresponding amount to the user.
        // Besides balance increase, function returns Ci index
        // TODO(perf): is it optimal to mint twice? Can't we return amount here
        //   and mint once below together with the _amount?
        (,, uint256 balanceIncrease, uint256 index) = cumulateBalanceInternal(_account);

        // TODO(redirects): do we need it?
        //if the user is redirecting his interest towards someone else,
        //we update the redirected balance of the redirection address by adding the accrued interest
        //and the amount deposited
//        updateRedirectedBalanceOfRedirectionAddressInternal(_account, balanceIncrease.add(_amount), 0);

        //mint an equivalent amount of tokens to cover the new deposit
        _mint(_account, _amount);

        emit MintOnDeposit(_account, _amount, balanceIncrease, index);
    }

    /**
    * @dev calculate the interest accrued by _user on a specific balance
    * @param _user the address of the user for which the interest is being accumulated
    * @param _balance the balance on which the interest is calculated
    * @return the interest rate accrued
    **/
    function calculateCumulatedBalanceInternal(
        address _user,
        uint256 _balance
    ) internal view returns (uint256) {
        return _balance
            .wadToRay()
            .rayMul(core.getReserveNormalizedIncome(underlyingAssetAddress))
            .rayDiv(userIndexes[_user])
            .rayToWad();
    }

    /**
    * @dev accumulates the accrued interest of the user to the principal balance
    * @param _user the address of the user for which the interest is being accumulated
    * @return the previous principal balance, the new principal balance, the balance increase
    * and the new user index
    **/
    function cumulateBalanceInternal(address _user)
        internal
        returns(uint256, uint256, uint256, uint256) {

        // Get the current balance of issued ATokens
        uint256 previousPrincipalBalance = super.balanceOf(_user);

        // Calculate the accrued interest since the last accumulation
        // balanceOf returns the principal balance + interest generated by the principal balance
        uint256 balanceIncrease = balanceOf(_user).sub(previousPrincipalBalance);

        //mints an amount of tokens equivalent to the amount accumulated
        _mint(_user, balanceIncrease);
        //updates the user index
        uint256 index = userIndexes[_user] = core.getReserveNormalizedIncome(underlyingAssetAddress);
        return (
            previousPrincipalBalance,
            previousPrincipalBalance.add(balanceIncrease),
            balanceIncrease,
            index
        );
    }

    /**
    * @dev returns the last index of the user, used to calculate the balance of the user
    * @param _user address of the user
    * @return the last user index
    **/
    function getUserIndex(address _user) external view returns(uint256) {
        return userIndexes[_user];
    }

    /**
    * @dev returns the principal balance of the user. The principal balance is the last
    * updated stored balance, which does not consider the perpetually accruing interest.
    * @param _user the address of the user
    * @return the principal balance of the user
    **/
    function principalBalanceOf(address _user) external view returns(uint256) {
        return super.balanceOf(_user);
    }
}
